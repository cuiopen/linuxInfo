### 线程  
在一个程序中的多个执行路线就叫做线程。（线程是一个进程内部的一个控制序列）
### 线程函数
* 创建新线程
```c
int pthread_create(pthread_t *thread,pthread_attr_t *attr,void *（*start_rountine）(void *),void *arg)
```
* 等待某个线程处理完    
```c
void* thread_result  
pthread_t a_thread  
void* pthread_join(a_thread,&thread_result)  
```
### 线程同步
* 信号量（如同看守一段代码的看门人）   
信号量是一个特殊类型的变量它可以被增加或者减少，但对其关键访问保证是原子操作，即使在多线程中也是如此。  
* 信号量分类
  * 二进制信号量  
  只有0和1两种取值
  * 计数信号量  
  可以取更大范围的值
* 互斥量（如同保护代码段的一个互斥设备）   

### 信号量函数
```c
//初始化
int sem_init(sem_t* sem,int pshared,unsigned  int value);
/**以原子的方式给信号量的值减1，如果此时为信号量为2，
线程会继续执行，信号量减1，如果此时为0就会等待，知道其他线程增加其不为0
*/
int sem_wait(sem_t* sem);
//以原子的方式给信号量的值加1
int set_post(sem_t* sem);
```
### 互斥量函数
```c
//初始化
int pthread_mutex_init(pthread_mutex_t* mutex,const pthread_mutexattr_t* mutexattr);
//加锁
int pthread_mutex_lock(pthread_mutex_t* mutex);
//解锁
int pthread_mutex_unlock(pthread_mutex_t* mutex);
//销毁
int pthread_mutex_destory(pthread_mutex_t* mutex);
```
pthread_nutex_init函数中的属性参数允许我们设置互斥量属性，而属性控制着互斥量行为。属性默认为fast。  
如果对已经加了锁的互斥量调用pthread_mutex_lock,程序就会被阻塞。而又因为拥有互斥量的这个线程正是现在  
被阻塞的线程，所以程序永远不会解锁进入死锁状态。这个问题可以通过改变互斥量的属性来解决，我们可以让他们
检查这种情况并返回一个错误，或者是递归操作给同一个线程加上多个锁，注意在后面执行同等的解锁操作。  
### 线程的属性
当我们创建的线程不需要向主线程返回信息，主线程也不想等待它结束后才能够执行（即不使用pthread_join方法）时。
假设我们提供一个对文件进行存储备份的工作线程，备份结束了，该线程可以直接终止了。没有必要向主线返回通知主线程
结束。我们可以创建这一类型的线程，它被称为脱离线程（detached thread）。可以通过修改线程属性或调用pthread_detach
的方法创建。
### 属性表格
|属性名|说明|
|---|---|
|detachedstate|两种状态：1 PTHREAD_CREATE_JOINABLE（默认状态，允许调用jion方法）</br>2 PTHREAD_CREATE_DETACHED（调用join方法无效）|


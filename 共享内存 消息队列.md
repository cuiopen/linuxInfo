### 进程间通信机制  
- [信号量](#信号量)
- [共享内存](#共享内存)
- [消息队列]()
### 信号量  
无论是多线程还是多进程程序中通常存在一部分临界代码，我们需要确保只有一个线程或者进程可以进入这个临界代码，并拥有对资源独占式的访问权。  
信号量的更正式定义为：他是一个特殊的变量，只允许对它进行等待（wait）和发送（signal）这两种操作。 
- P(信号量变量)：用于等待
- V（信号量变量）：用于发送信号
### 信号量定义  
最简单的信号量是二进制信号量，即只能取0和1,可以取多个正整数的信号量被称为通用信号量。

|信号量符号|含义|
|---|---|
|p(sv)|如果sv的值大于0，就给它减去1：如果它的值为0就挂起改进程的执行|
|v(sv)|如果有其他进程因为等待sv而被挂起，就让它恢复运行：如果没有进程因等待sv而挂起就给它加1|
```c
#include <sys/sem.h>
//用来直接控制信号量信息
//参数1 是semget函数返回的信号量标示符
//参数2 信号量编号，当需要用到成组信号量时，就要用到这个参数它一般取值为0，标示唯一的一个信号量
//command参数是将要采取的动作
//
int semctl(int sem_id,int sem_num,int command,...);
//创建一个新的信号量或取得一个已有信号的键
//参数1 整数值，不相关的进程可以通过它访问同一信号量。程序对所有的信号量的访问都是间接的,它先提供一个键，再由系统生成一个相关的信号量标示符。
//只有semget函数才能直接使用信号量键。其他信号量函数都是使用有semget函数返回的信号量标示符。
//num_sems参数指定需要的信号个数。他几乎总是取值为1
//sem_flags参数是一组标志，它的低端的9个比特是该信号量的权限 类似于文件的权限
int semget(key_t key,int num_sems,int sem_flags);
//semop用于改变信号量的值
//参数1 sem_id是sem_get函数的返回信号量标示符。
//参数2 struct sembuf{
//short sem_num;信号量编号，除非需要一组，否则取值一般为0；
//short sem_op;表示信号量在一次操作中需要改变的值（可以使用非1的值来改变信号量的值，通常只有两个值-1和1。-1标示p操作，1标示v操作）
//short sem_flag;一般设为SEM_UNDO.(当进程意外结束，没有释放该信号，操作系统会自动释放该进程持有的信号)
//}
int semop(int sem_id,struct sembuf *sem_ops,size_t num_sem_ops);
```
### 共享内存
允许不想关的两个进程访问同一逻辑内存。共享内存是在两个正在运行的进程之间传递数据的一种非常有效的方式。虽然X/open标准并没有对它做出要求，但大多数  
共享内存的具体实现，都把有不同内存之间共享的内存安排为同一段物理内存。它IPC为进程创建的一个特殊的地址范围，它将出现在该进程的地址空间中。其它进程
可以将同一段共享内存连接到它们自己的地空间中。所有的进程都可以访问共享内存中的地址。如果某个进程向共享内存写入数据，所做的改动将立刻被可以访问同一段
共享内存的任何进程看到。共享内存虽然是多进程间共享和传递数据的有效方式，但并未提供同步机制，所以通常需要用其他的机制来同步对共享内存的访问，一般用
共享内存来提供对大块内存区域的有效访问，同时通过传递小消息来同步内存访问。  
```c
#include<sys/shm.h>
//第一次创建共享内存段时，它不能被任何进程访问。要想启用对该共享内存的访问，必须将其连接到一个进程的地址空间中，这项工作由shmat函数来完成
//第一个参数shm_id是由shmget返回的共享内存标示符
//第二个参数shm_addr指定的是共享内存连接到当前进程中的地址位置。它通常是一个空指针，表示让系统选择共享内存出现的地址。
//第三个参数shmflg是一组标志。它的两个可能取值是SHM_RND（这个标志与shm_addr联合使用，用来控制共享内存连接的地址）
//和SHM_RDONLY(它使得连接的内存段只读),我们很少需要控制内存连接的地址，通常是让系统选择一个地址，否则会使应用程序对硬件依赖过高
void *shmat(int shm_id,const void *shm_addr,int shmflg);
//struct shmid_ds{
//uid_t shm_perm.uid
//uid_t shm_perm.gid
//uid_t shm_perm.mode
//}
//参数1 shmget返回的id 参数2command是需要采取的动作，可以取三个值IPC_STAT 把shmid_ds结构中的数据设置为共享内存当前的关联值。
//IPC_SET 如果进程权限足够，就把共享内存当前的关联值设置为shmid_ds结构中的值 IPC_RMID 删除共享内存段
//参数3 buf是一个指针，它指向包含共享内存模式和访问权限结构。通常已经被删除的处于连接状态的共享内存段还能继续使用，知道他从最后一个进程分离
int shmctl(int shm_id,int cmd,struct shmid_ds *buf);
//将共享内存从当前的进程中分离，它的参数是shmat函数返回的指针。注意将共享内存分离并未删除它，只是使得改共享内存对当前进程不在可用。
int shmdt(const void *shm_addr);
//创建共享内存，与信号量一样提供一个参数key，它有效的为共享内存段命名。shmget函数返回一个共享内存标示符，改标识符将用于后续的共享内存函数。
//有一个特殊的键值IPC_PRIVATE,它用于创建一个只属于创建进程的共享内存。通常不会用到这个值，并且在一些linux系统中私有的共享内存并不是真正
//的私有。
//第二个参数以字节为单位指定需要共享的内存容量
//第三个参数shmflg包含9个比特权限标志(0777)，有IPC_CREATE定义的一个特殊的比特权限标志位和权限标志位按位或才能创建一个新的共享内存段。
int shmget(key_t key,size_t size,int shmflg)；
```

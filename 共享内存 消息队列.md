### 进程间通信机制  
- [信号量](#信号量)
- [共享内存]()
- [消息队列]()
### 信号量  
无论是多线程还是多进程程序中通常存在一部分临界代码，我们需要确保只有一个线程或者进程可以进入这个临界代码，并拥有对资源独占式的访问权。  
信号量的更正式定义为：他是一个特殊的变量，只允许对它进行等待（wait）和发送（signal）这两种操作。 
- P(信号量变量)：用于等待
- V（信号量变量）：用于发送信号
### 信号量定义  
最简单的信号量是二进制信号量，即只能取0和1,可以取多个正整数的信号量被称为通用信号量。

|信号量符号|含义|
|---|---|
|p(sv)|如果sv的值大于0，就给它减去1：如果它的值为0就挂起改进程的执行|
|v(sv)|如果有其他进程因为等待sv而被挂起，就让它恢复运行：如果没有进程因等待sv而挂起就给它加1|
```c
#include <sys/sem.h>
//用来直接控制信号量信息
//参数1 是semget函数返回的信号量标示符
//参数2 信号量编号，当需要用到成组信号量时，就要用到这个参数它一般取值为0，标示唯一的一个信号量
//command参数是将要采取的动作
//
int semctl(int sem_id,int sem_num,int command,...);
//创建一个新的信号量或取得一个已有信号的键
//参数1 整数值，不相关的进程可以通过它访问同一信号量。程序对所有的信号量的访问都是间接的,它先提供一个键，再由系统生成一个相关的信号量标示符。
//只有semget函数才能直接使用信号量键。其他信号量函数都是使用有semget函数返回的信号量标示符。
//num_sems参数指定需要的信号个数。他几乎总是取值为1
//sem_flags参数是一组标志，它的低端的9个比特是该信号量的权限 类似于文件的权限
int semget(key_t key,int num_sems,int sem_flags);
//semop用于改变信号量的值
//参数1 sem_id是sem_get函数的返回信号量标示符。
//参数2 struct sembuf{
//short sem_num;信号量编号，除非需要一组，否则取值一般为0；
//short sem_op;表示信号量在一次操作中需要改变的值（可以使用非1的值来改变信号量的值，通常只有两个值-1和1。-1标示p操作，1标示v操作）
//short sem_flag;一般设为SEM_UNDO.(当进程意外结束，没有释放该信号，操作系统会自动释放该进程持有的信号)
//}
int semop(int sem_id,struct sembuf *sem_ops,size_t num_sem_ops);
```

### 套接字
是一种通信机制，凭借这种机制，客户/服务器系统的开发工作既可以在本地单机上进行，也可以跨网络进行。linux所提供的功能（打印服务器，连接数据库，和提供web页面）和网络工具（如用于远程登录的rlogin和用于文件传输的ftp），通常都是通过套接字来进行通信的。套接字的创建和使用与管道是有区别的，因为套接字明确的将客户端和服务器分开来。套接字机制可以实现将多个客户连接到一个服务器。
### 套接字连接
服务器应用程序调用系统socket来创建一个套接字，它是系统分配给该服务器进程的类似文件描述符的资源，但不能与其他进程共享。接下来，服务进程会给套接字起名字，本地套接字的名字是Linux文件系统的文件名，一般放在/tmp或/usr/tmp目录中。对于网络套接字，它的名字是与客户连接的特定网络有关的服务标示符（端口号或访问点）。这个标识符允许Linux将进入的针对特定端口号的连接转到正确的服务器进程。例如，Web服务器一般在80上创建一个套接字，这是一个专用于此目的的标示符。Web浏览器知道对于用户想要访问Web站点内，应该使用端口80来创建http连接。我们用系统调用bind来给套接字命名。然后服务器开进程就开始等待客户连接到这个命名套接字。系统调用listen的作用是，创建一个对列并将其用于存放来自客户的进入连接。服务器通过系统调用accept来接受客户连接。服务器调用accept时，他会创建一个与原有的命名套接字不通的新套接字，这个新套接字只用于和特定的客户进行通信。而命名套接字则被保留下来继续处理来自其他客户的连接。如果服务器编写得当，他就可以充分利用多个连接带来的好处。Web服务器就会这么做以同时服务来自许多客户的页面请求。对于一个简单的服务器来说，后续的客户将在监听对列中等待，知道服务器在此准备就绪。  
基于套接字系统的客户端更加简单，客户首先调用socket创建一个未命名套接字，然后将服务器的命名套接字作为一个地址来调用connect与服务器创建连接。一旦连接建立我们就可以像使用底层的文件描述符那样使用套接字来实现双向的数据通信。  
### 套接字属性
套接字的特性由3个属性确定：套接字还用地址作为它的名字。地址的格式随域（又称为协议族，protocolfamily）的不同而不同。每个协议族又可以使用一个或多个地址族 定义地址格式。
- 域（domain）  
域指定套接字通信中使用的网络介质，最常用的是AF_INET,它是指internet网络。许多Linux局域网都使用的是该网络。
- 类型(type)  
一个套接字可能有多种不同的通信方式，而每种通信方式又有其不同的特性。但AF_UNIX域的套接字没有这样的问题，它们提供了一个可靠的双向通信路径。在网络域中我们就需要注意底层的网络特性，以及不同的通信机制是如何受到它们影响的。  
因特网协议提供了两种通信机制：流（stream）和数据报（datagram）。它们有着截然不同的服务层次。  
1流套接字  
流套接字（在某些方面类似于标准的输入/输出流）提供一个有序可靠双向字节流连接。因此发送的数据可以确保不会丢失，复制或乱序到达。并且在这一过程中发生的错误也不会显示出来，大的消息将被分片、传输、在重组。流套接字类型由SOCK_STREAM指定，在AF_INET域中通过TCP/IP连接实现，他也是AF_UNIX域中常用的套接字类型。  
2数据报套接字  
与流套接字相反，由类型SOCK_DGRAM指定的数据报套接字不建立和维持一个连接。它对可以发送的数据报的长度有限制，数据报作为一个单独的网络消息被传输。它可能丢失、复制、或乱序到达。数据报套接字是在AF_INET域中通过UDP/IP连接实现的，它提供的是一种无序的不可靠的服务（UDP用户数据报协议）。但从资源角度来看相对开销较小，因为不需要维持网络连接。而且无需花费时间来建立连接，所以它们的速度很快。数据报适用于信息服务中的单次查询（sing-shot）,主要用来提供日常状态信息或执行低优先级的日志记录。它的优点是服务器的崩溃不会给客户造成不便，也不会要求客户重启，因为基于数据报的服务器通常不保留连接信息，所以可以在不打扰客户的前提下停止并重启。 
- 协议(protocol)  
只要底层的传输机制允许不止一个协议来提供要求的套接字类型，我们就可以为套接字选择一个特定的协议。
### 套接字函数
* 创建套接字
```c
#include<sys/types.h>
#include<sys/socket.h>
//参数1domian表明域，参数2type指定套接字通信类型。参数3protocol参数指定使用协议
//通信所需的协议一般由套接字的域来决定，通常不需要选择，只有当需要选择时，我们才会用到protocol参数。改参数为0表示使用默认协议。
//函数返回一个文件描述符。类似于底层的文件描述符。。当套接字连接到另一端的套接字后。我们可以调用read和write函数。通过描述符在
//套接字上发送和接受数据
int socket(int domian,int type,int protocol);
```
创建的套接字是一条通信线路的一个端点。  

|域|说明|
|---|---|
|AF_UNIX|UNIX域协议（文件系统套接字）|
|AF_INET|ARPA因特网协议（UNIX网络套接字）|
|AF_ISO|ISO标准协议|
|AF_NS|施乐（Xerox）网络系统协议|
|AF_IPX|NovellIPX协议|
|AF_APPLETALK|Appletalk DDs|  
* 套接字地址  
每个套接字域都有自己的地址格式。对于AF_UNIX域套接字来说，它的地址由结构sockaddr_un来描述改结构定义在头文件sys/un.h中。
```c 
struct  sockaddr_un{
sa_family_t sun_family;//AF_UNIX
char        sun_path[];//pathName 文件路径
};
struct sockaddr_in{
short int   sin_family;//AF_INET
unsigned short int  sin_port;//portNumber 端口号 
struct      in_addr;   //InternetAddress 网络地址IP地址结构 
};
//ip结构体
struct in_addr {
unsigned long int    s_addr;
};
```
对套接字处理的系统调用可能需要接受不同的地址类型，每种地址格式都用一种类似的结构来描述，它们都以一个指定地址类型（套接字域）的成员如sun_family在AF_UNIX域中，套接字地址由结构中的sun_path成员中的文件名指定。在AF_INET中IP地址中的4个字节组成32位的值，一个AF_INET套接字由它的域、IP地址和端口号完全确定。  
* 命名套接字
要想让通过socket调用创建的套接字可以被其他进程使用，服务器服务器进程必须给该套接字命名。这样AF_UNIX就会关联到正确的系统路径名。AF_INET就会关联到一个IP端口号。
```c
#include<sys/socket.h>
//bind系统调用把参数address中的地址分配给与文件描述符socket关联的未命名套接字，地址结构的长度由参数address_len传递。地址长度和格式取决于地址族。
//bind调用需要将一个特定的地址结构指针指向通用的地址类型。
int bind(int socket,const struct sockaddr *address,size_t address_len);
```  
* 创建套接字对列
为了能够在套接字上接受进入的连接，服务器程序必须创建一个对列来保存未处理请求。
```c
#include<sys/socket.h>
//参数1 socket函数返回值 参数2最大进入连接数超过这个数字连接将会别拒绝，导致客户连接请求失败
int listen(int socket,int backlog);
```
*  接受连接
```c
#include<sys/socket.h>
int accept(int socket,struct sockaddr *address,size_t *address_len);
```
accept系统调用只有当有客户程序试图连接到由socket参数指定的套接字接口上时才返回。这里的客户是指，在套接字对列中排在第一个的未处理连接。accept函数将创建一个新的套接字来与该客户进行通信，并且返回新的套接字描述符。新的套接字类型和服务器监听的套接字类型是一样的。套接字必须先由bind调用命名，listen调用分配对列。连接客户地址将被放在address参数指向的地址结构中，如果不关心客户地址可以address可以为空指针。address_len指定客户长度，超过长度会被截断，如果对列中没有未处理的连接，accept将阻塞知道有客户连接为止。我们也可以通过文件描述符设置函数fctnl设置O_NONBLOCK标志来改变这一行为。
